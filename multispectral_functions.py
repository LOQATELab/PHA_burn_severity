{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b28d8db2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ALL FUNCTIONS\n",
    "\n",
    "def nbr_clip(dir, \n",
    "             shape, \n",
    "             plot=False, \n",
    "             save=False):\n",
    "    '''Takes in image and clips the raster to study basins.\n",
    "        \n",
    "        CLIP OPTIONS:\n",
    "        all_touched (boolean, OPTIONAL): If True, all pixels touched by geometries\n",
    "        will be burned in. If false, only pixels whose center is within the polygon \n",
    "        or that are selected by Bresenhamâ€™s line algorithm will be burned in.\n",
    "        \n",
    "        drop (bool, optional): If True, drop the data outside of the extent of the \n",
    "        mask geoemtries Otherwise, it will return the same raster with the data masked. \n",
    "        Default is True.\n",
    "        \n",
    "        invert (boolean, optional): If False, pixels that do not overlap shapes will be\n",
    "        set as nodata. Otherwise, pixels that overlap the shapes will be set as nodata. \n",
    "        False by default.'''\n",
    "    \n",
    "    NIR_path = glob.glob(dir + '/*B8A.jp2')\n",
    "    NIR = rxr.open_rasterio(NIR_path[0], masked=True)\n",
    "    SWIR_path = glob.glob(dir + '/*B12.jp2')\n",
    "    SWIR = rxr.open_rasterio(SWIR_path[0], masked=True)\n",
    "    \n",
    "    name = os.path.basename(NIR_path[0])\n",
    "    name_split = name.split('_')\n",
    "    val = name_split[1]\n",
    "    date = val[:8]\n",
    "    sdc = f\"{val[4:6]}/{val[6:8]}/{val[0:4]}\"\n",
    "    \n",
    "    shape = gpd.read_file(os.path.join(dirPolyLoc, filename))\n",
    "    b_name = filename.split('.')\n",
    "    basin = b_name[0]\n",
    "    basin_NIR = NIR.rio.clip(shape.geometry.values,\n",
    "                                shape.crs,\n",
    "                                all_touched = False,\n",
    "                                drop = True,\n",
    "                                invert = False)\n",
    "    basin_SWIR = SWIR.rio.clip(shape.geometry.values,\n",
    "                                shape.crs,\n",
    "                                all_touched = False,\n",
    "                                drop = True,\n",
    "                                invert = False)\n",
    "    \n",
    "    #basin_clip.plot()\n",
    "    \n",
    "    \n",
    "    nbr = (basin_NIR - basin_SWIR) / (basin_NIR + basin_SWIR)\n",
    "    if plot == True:\n",
    "        nbr.plot(\n",
    "            cmap = 'gray',\n",
    "            vmax = 1,\n",
    "            vmin = -1)\n",
    "        plt.title(f\"Basin {basin} Normalized Burn Ratio: {sdc}\")\n",
    "   \n",
    "    if save == True:\n",
    "        outname = f\"{date}_{basin}_nbr.tif\"\n",
    "        nbr.rio.to_raster(os.path.join(nbr_out, outname), driver='GTIFF')\n",
    "    \n",
    "    return nbr\n",
    "#####\n",
    "def dnbr(pre_fire, \n",
    "         post_fire, \n",
    "         plot=False, \n",
    "         save=False):\n",
    "    '''Takes in nbr functions outputs and calculates the differenced normalized burn ratio.\n",
    "        This function outputs individual basin results.'''\n",
    "    \n",
    "    dnbr = pre_fire - post_fire\n",
    "    \n",
    "    if plot == True:\n",
    "        dnbr.plot(\n",
    "            cmap = 'gray',\n",
    "            vmax = 1,\n",
    "            vmin = -1)\n",
    "        plt.title(f\"Basin {basin} Differenced Normalized Burn Ratio\")\n",
    "        \n",
    "    if save == True:\n",
    "        outname = f\"{basin}_dnbr.tif\"\n",
    "        dnbr.rio.to_raster(os.path.join(dnbr_out, outname), driver='GTIFF')\n",
    "        \n",
    "    return dnbr\n",
    "\n",
    "\n",
    "def ppp(dnbr, \n",
    "          plot=False, \n",
    "          save=False):\n",
    "    # Set x_value directory\n",
    "    x_values_df = pd.read_csv('/mnt/nfs/lss/meerdink/home/skzebarth/masters/basin_data/x_values.csv', \n",
    "                          delimiter=',')\n",
    "    \n",
    "    # Coefficients for Southern California\n",
    "    b = -3.63\n",
    "    b_1 = 0.41\n",
    "    b2 = 0.67\n",
    "    b_2 = np.array(b2)\n",
    "    b_3 = 0.7\n",
    "    \n",
    "    \n",
    "    dnbr_flat = dnbr.values.flatten()\n",
    "    pixarr = np.empty((dnbr_flat.shape[0]), dtype= float)\n",
    "    pixarr[:] = np.nan\n",
    "    x = np.where(np.isnan(dnbr_flat) == False)\n",
    "        \n",
    "    # Getting the data from dnbr_flat\n",
    "    dnbrdata = dnbr_flat[x]\n",
    "        \n",
    "    # Matching index of x_values_df[basin_id] to shapefile\n",
    "    individual_basin = x_values_df.index[x_values_df['basin_id'] == int(basin)]\n",
    "        \n",
    "    # Pulling individual values from x_1 and x_3, creating pixel values for x_2 denoted by s & s1\n",
    "    x_1 = x_values_df['x1'][individual_basin]\n",
    "    x_3 = x_values_df['x3'][individual_basin]\n",
    "    s = np.multiply(dnbrdata, b_2)\n",
    "    s1 = np.multiply(s, val)\n",
    "       \n",
    "    # Per pixel analysis, probability stored in empty list p1\n",
    "    p1 = []\n",
    "    for i in s1:\n",
    "        lnx =  b + (b_1 * x_1 * val) + i + (b_3 * x_3 * val)\n",
    "        prob = (e ** lnx) / (1.0 + e ** lnx)\n",
    "        p1.append(prob)\n",
    "        \n",
    "    # Append probability array, flatten data, reshape into image\n",
    "    prob_arr = np.array(p1)\n",
    "    p_final = prob_arr.flatten()\n",
    "    pixarr[x] = p_final\n",
    "    pixarrImg = pixarr.reshape((dnbr.shape[1], dnbr.shape[2]))\n",
    "    out_dnbr = xr.Dataset()\n",
    "    out_dnbr = xr.DataArray(pixarrImg, dims = ('y', 'x'),\n",
    "                            coords = {'x': dnbr.coords['x'],\n",
    "                                      'y': dnbr.coords['y']})\n",
    "\n",
    "    if plot == True:\n",
    "        out_dnbr.plot(\n",
    "            cmap = 'gnuplot',\n",
    "            vmax = 1,\n",
    "            vmin = 0)\n",
    "        plt.title(f\"Basin {basin} Per Pixel Initiation Probablilty, R = {int(val*4)}mm/hr\")\n",
    "    \n",
    "    if save == True:\n",
    "        outname = f\"{basin}_ppp_{int(val*4)}mmhr.tif\"\n",
    "        out_dnbr.rio.to_raster(os.path.join(ppp_out, outname), driver='GTIFF')\n",
    "        print(f\"Basin {basin} {int(val*4)}mm/hr per pixel analysis saved as geotiff\")\n",
    "        \n",
    "        print(f\"Basin {basin} {int(val*4)}mm/hr per pixel analysis complete\")\n",
    "    return out_dnbr\n",
    "\n",
    "#####\n",
    "\n",
    "def rgb(dir, \n",
    "        shape, \n",
    "        plot=False, \n",
    "        save=False):\n",
    "    \n",
    "    def normalize(array):\n",
    "        \"\"\"Normalizes numpy arrays into scale 0.0 - 1.0\"\"\"\n",
    "        array_min, array_max = array.min(), array.max()\n",
    "        return ((array - array_min)/(array_max - array_min))\n",
    "    def resample(rst):\n",
    "        scale_factor = 1/2\n",
    "        new_width = rst.rio.width * scale_factor\n",
    "        new_height = rst.rio.height * scale_factor\n",
    "        sampled = rst.rio.reproject(rst.rio.crs, \n",
    "                                    shape=((int(new_height), int(new_width))),\n",
    "                                    resampling = Resampling.nearest)\n",
    "        return sampled\n",
    "    \n",
    "    # Set RGB Bands,Sentinel-2 is red(B04), green(B03), blue(B02)\n",
    "    imageRed = glob.glob(dir + '/*B04.jp2')\n",
    "    imageGreen = glob.glob(dir + '/*B03.jp2')\n",
    "    imageBlue = glob.glob(dir + '/*B02.jp2')\n",
    "    name = os.path.basename(imageRed[0])\n",
    "    name_split = name.split('_')\n",
    "    val = name_split[1]\n",
    "    date = val[:8]\n",
    "    sdc = f\"{val[4:6]}/{val[6:8]}/{val[0:4]}\"\n",
    "    imageRed_open = rxr.open_rasterio(imageRed[0], masked=True)\n",
    "    imageBlue_open = rxr.open_rasterio(imageBlue[0], masked=True)\n",
    "    imageGreen_open = rxr.open_rasterio(imageGreen[0], masked=True)\n",
    "    \n",
    "    shape = gpd.read_file(os.path.join(dirPolyLoc, filename))\n",
    "    b_name = filename.split('.')\n",
    "    basin = b_name[0]\n",
    "    \n",
    "    redClip = imageRed_open.rio.clip(shape.geometry.values, \n",
    "                                     shape.crs, \n",
    "                                     all_touched=False, \n",
    "                                     drop=True, \n",
    "                                     invert=False)\n",
    "    blueClip = imageBlue_open.rio.clip(shape.geometry.values, \n",
    "                                       shape.crs, \n",
    "                                       all_touched=False, \n",
    "                                       drop=True, \n",
    "                                       invert=False)\n",
    "    greenClip = imageGreen_open.rio.clip(shape.geometry.values, \n",
    "                                         shape.crs, \n",
    "                                         all_touched=False, \n",
    "                                         drop=True, \n",
    "                                         invert=False)\n",
    "    \n",
    "    # Normalize clip so rgb display is bright enough\n",
    "    redn = normalize(redClip)\n",
    "    bluen = normalize(blueClip)\n",
    "    greenn = normalize(greenClip)\n",
    "    \n",
    "    # Resample from 10m to 20m spatial resolution\n",
    "    red_rs = resample(redn)\n",
    "    blue_rs = resample(bluen)\n",
    "    green_rs = resample(greenn)\n",
    "    \n",
    "    # Pull band information from each array\n",
    "    redData = red_rs.data[0,:,:]\n",
    "    blueData = blue_rs.data[0,:,:]\n",
    "    greenData = green_rs.data[0,:,:]\n",
    "    \n",
    "    # Create and plot mask\n",
    "    dataPlot = np.zeros((redData.shape[0],redData.shape[1],3))\n",
    "    dataPlot[:,:,0] = redData\n",
    "    dataPlot[:,:,1] = greenData\n",
    "    dataPlot[:,:,2] = blueData\n",
    "    dataPlotMask = np.ma.masked_where(np.isnan(dataPlot), dataPlot)\n",
    "    img = xr.Dataset()\n",
    "    img = xr.DataArray(dataPlotMask,\n",
    "                           dims = ('y', 'x', 'band'),\n",
    "                           coords ={'y': red_rs.coords['y'], \n",
    "                                    'x': red_rs.coords['x'],\n",
    "                                    'band': [\"red\", \"green\", \"blue\"]})\n",
    "    \n",
    "    \n",
    "    # Transpose array for geotiff output\n",
    "    out_img = img.transpose('band', 'y', 'x')\n",
    "    \n",
    "    if plot == True:\n",
    "        img.plot.imshow()\n",
    "        plt.title(f'Basin {basin} RGB: {sdc}')\n",
    "        plt.show()\n",
    "    #Saving\n",
    "    if save == True:\n",
    "        outname = f\"{basin}_{date}_rgb.tif\"\n",
    "        out_img.rio.to_raster(os.path.join(rgb_out, outname), driver='GTIFF')\n",
    "    print(f\"Basin {basin} RGB combine complete\")\n",
    "    return img\n",
    "\n",
    "####\n",
    "def dnbr_hist(data):\n",
    "    avg = np.mean(data)\n",
    "    fig, ax = plt.subplots()\n",
    "        \n",
    "    data.plot.hist(ax=ax,\n",
    "                   color='c',\n",
    "                   edgecolor='k',\n",
    "                   bins=20)\n",
    "    plt.axvline(avg, color='k', linestyle='dashed', linewidth=2)\n",
    "    min_ylim, max_ylim = plt.ylim()\n",
    "    plt.text(avg*1.05, max_ylim*0.95, 'Mean: {:.3f}'.format(avg))   \n",
    "    ax.set(\n",
    "        title = f\"Basin {basin} dNBR Distribution\",\n",
    "        xlabel='dNBR',\n",
    "        ylabel='Frequency')\n",
    "    plt.show()\n",
    "    return fig\n",
    "\n",
    "def ppp_hist(data):\n",
    "    avg = np.mean(data)\n",
    "    fig, ax = plt.subplots()\n",
    "        \n",
    "    data.plot.hist(ax=ax,\n",
    "                   color='c',\n",
    "                   edgecolor='k',\n",
    "                   bins=20)\n",
    "    plt.axvline(avg, color='k', linestyle='dashed', linewidth=2)\n",
    "    min_ylim, max_ylim = plt.ylim()\n",
    "    plt.text(avg*1.05, max_ylim*0.95, 'Mean: {:.3f}'.format(avg))   \n",
    "    ax.set(\n",
    "        title = f\"Basin {basin} Per Pixel Probability Distribution\",\n",
    "        xlabel='Debris Flow Initiation Likelihood',\n",
    "        ylabel='Frequency')\n",
    "    #plt.show()\n",
    "    return fig\n",
    "\n",
    "#####\n",
    "\n",
    "\n",
    "\n",
    "def fig_1x3(tci, \n",
    "             bs, \n",
    "             prob,\n",
    "             savefig=False):\n",
    "    # Create figures\n",
    "    fig, ax = plt.subplots(1, 3, \n",
    "                           figsize=(14,4), \n",
    "                           gridspec_kw={'width_ratios':[1, 1.2, 1.2]})\n",
    "    fig.suptitle(f'Basin {basin} with {int(val*4)}mm/hr Design Storm', fontsize=15, fontweight='bold')\n",
    "    \n",
    "    # RGB imagery\n",
    "    tci.plot.imshow(ax=ax[0])\n",
    "    ax[0].axis('off')\n",
    "    ax[0].set_title('RGB', y=-.1)\n",
    "    \n",
    "    # dNBR imagery\n",
    "    value1 = np.mean(bs)\n",
    "    mean1 = value1.item()\n",
    "    bs.plot(ax=ax[1], \n",
    "            cmap = 'gray',\n",
    "            vmax = 1,\n",
    "            vmin = -1)\n",
    "    ax[1].set_title(f'Basin dNBR: {mean1:.3g}', y=-.1)\n",
    "    ax[1].axis('off')\n",
    "    \n",
    "    # PPP imagery\n",
    "    value2 = np.mean(prob)\n",
    "    mean2 = value2.item()\n",
    "    prob.plot(ax=ax[2], \n",
    "            cmap = 'gnuplot',\n",
    "            vmax = 1,\n",
    "            vmin = 0)\n",
    "    ax[2].set_title(f'Basin P: {mean2:.3g}', y=-.1)\n",
    "    ax[2].axis('off')\n",
    "    if savefig == True:\n",
    "       plt.savefig(os.path.join(fig_out, f'{basin}_{int(val*4)}mmhr_vis_1by3.png'))\n",
    "    plt.show()\n",
    "    return fig\n",
    "\n",
    "#####\n",
    "\n",
    "def fig_1x2(dnbr, \n",
    "            ppp, \n",
    "            savefig=False):\n",
    "     fig, ax = plt.subplots(1, 2, \n",
    "                           figsize=(14,5))\n",
    "     fig.suptitle(f'Basin {basin} Data Distribution with {int(val*4)}mm/hr Design Storm', fontsize=15, fontweight='bold')\n",
    "    \n",
    "     # dNBR histogram\n",
    "    \n",
    "     value1 = np.mean(dnbr)\n",
    "     dnbravg = value1.item()\n",
    "     dnbr.plot.hist(\n",
    "                    color= 'c',\n",
    "                    edgecolor='k',\n",
    "                    bins=20,\n",
    "                    ax=ax[0])\n",
    "     ax[0].set(\n",
    "         title = 'dNBR',\n",
    "         xlabel=f'Mean: {dnbravg: .3g}',\n",
    "         ylabel='Frequency')\n",
    "     ax[0].axvline(dnbravg, \n",
    "                 color='r', \n",
    "                 linestyle='solid', \n",
    "                 linewidth=2,\n",
    "                 ) \n",
    "     \n",
    "     \n",
    "     \n",
    "     value2 = np.mean(ppp)\n",
    "     pppavg = value2.item()\n",
    "     ppp.plot.hist(\n",
    "                    color='c',\n",
    "                    edgecolor='k',\n",
    "                    bins=20,\n",
    "                    ax=ax[1])\n",
    "     \n",
    "     ax[1].axvline(pppavg, \n",
    "                 color='r', \n",
    "                 linestyle='solid', \n",
    "                 linewidth=2,\n",
    "                 )  \n",
    "     ax[1].set(\n",
    "        title= 'Per Pixel Probability',\n",
    "        xlabel=f'Mean: {pppavg: .3g}')\n",
    "        \n",
    "     if savefig == True:\n",
    "        plt.savefig(os.path.join(fig_out, f'{basin}_{int(val*4)}mmhr_hist.png'))\n",
    "     plt.show()\n",
    "     return fig\n",
    "\n",
    "def fig_1x4(tci,\n",
    "             tci2,\n",
    "             bs, \n",
    "             prob,\n",
    "             savefig=False):\n",
    "    # Create figures\n",
    "    fig, ax = plt.subplots(1, 4, \n",
    "                           figsize=(18,4), \n",
    "                           gridspec_kw={'width_ratios':[1, 1, 1.2, 1.2]})\n",
    "    fig.suptitle(f'Basin {basin} with {int(val*4)}mm/hr Design Storm', fontsize=15, fontweight='bold')\n",
    "    \n",
    "    # RGB imagery\n",
    "    tci.plot.imshow(ax=ax[0])\n",
    "    ax[0].axis('off')\n",
    "    ax[0].set_title('Pre-fire', y=-.1)\n",
    "    \n",
    "    tci2.plot.imshow(ax=ax[1])\n",
    "    ax[1].axis('off')\n",
    "    ax[1].set_title('Post-fire', y=-.1)\n",
    "    \n",
    "    # dNBR imagery\n",
    "    value1 = np.mean(bs)\n",
    "    mean1 = value1.item()\n",
    "    bs.plot(ax=ax[2], \n",
    "            cmap = 'gray',\n",
    "            vmax = 1,\n",
    "            vmin = -1)\n",
    "    ax[2].set_title(f'Basin dNBR: {mean1:.3g}', y=-.1)\n",
    "    ax[2].axis('off')\n",
    "    \n",
    "    # PPP imagery\n",
    "    value2 = np.mean(prob)\n",
    "    mean2 = value2.item()\n",
    "    prob.plot(ax=ax[3], \n",
    "            cmap = 'gnuplot',\n",
    "            vmax = 1,\n",
    "            vmin = 0)\n",
    "    ax[3].set_title(f'Basin P: {mean2:.3g}', y=-.1)\n",
    "    ax[3].axis('off')\n",
    "    if savefig == True:\n",
    "       plt.savefig(os.path.join(fig_out, f'{basin}_{int(val*4)}mmhr_vis_by4.png'))\n",
    "    plt.show()\n",
    "    return fig\n",
    "\n",
    "def fig_6(tci, tci2, dnbr, ppp, savefig=False):\n",
    "     value1 = np.mean(dnbr)\n",
    "     mean1 = value1.item()\n",
    "     value2 = np.mean(ppp)\n",
    "     mean2 = value2.item()\n",
    "    \n",
    "     fig = plt.figure(figsize = (13,8))\n",
    "     gs = gridspec.GridSpec(2, 3, \n",
    "                            width_ratios=[1,1.2,1.2])\n",
    "     fig.suptitle(f'Basin {basin}, {int(val*4)}mm/hr Design Storm', fontsize=15, fontweight='bold')\n",
    "    \n",
    "     # Create axes for top three images\n",
    "     ax1 = fig.add_subplot(gs[0, 0])\n",
    "     ax2 = fig.add_subplot(gs[0, 1])\n",
    "     ax3 = fig.add_subplot(gs[0, 2])\n",
    "\n",
    "     # Create axes for bottom two images\n",
    "     ax4 = fig.add_subplot(gs[1, 0])\n",
    "     ax5 = fig.add_subplot(gs[1, 1])\n",
    "     ax6 = fig.add_subplot(gs[1, 2])\n",
    "     \n",
    "     fig.subplots_adjust(wspace=.25)\n",
    "     # Plot images on axes\n",
    "     tci.plot.imshow(ax=ax1)\n",
    "     ax1.axis('off')\n",
    "     ax1.set_title('Pre-fire', y=-.1)\n",
    "     \n",
    "     dnbr.plot(ax=ax2, \n",
    "            cmap = 'gray',\n",
    "            vmax = 1,\n",
    "            vmin = -1)\n",
    "     ax2.set_title(f'Basin dNBR: {mean1:.3g}', y=-.1)\n",
    "     ax2.axis('off')\n",
    "     \n",
    "     ppp.plot(ax=ax3, \n",
    "            cmap = 'gnuplot',\n",
    "            vmax = 1,\n",
    "            vmin = 0)\n",
    "     ax3.set_title(f'Basin P: {mean2:.3g}', y=-.1)\n",
    "     ax3.axis('off')\n",
    "     \n",
    "     tci2.plot.imshow(ax=ax4)\n",
    "     ax4.axis('off')\n",
    "     ax4.set_title('Post-fire', y=-.17)   \n",
    "    \n",
    "     dnbr.plot.hist(\n",
    "                    color= 'c',\n",
    "                    edgecolor='k',\n",
    "                    bins=20,\n",
    "                    ax=ax5)\n",
    "     ax5.set(\n",
    "         title='',\n",
    "         xlabel=f'dNBR Distribution, Mean: {mean1: .3g}',\n",
    "         ylabel='Frequency')\n",
    "     ax5.axvline(mean1, \n",
    "                 color='r', \n",
    "                 linestyle='solid', \n",
    "                 linewidth=2,\n",
    "                 )\n",
    "     ppp.plot.hist(\n",
    "                    color='c',\n",
    "                    edgecolor='k',\n",
    "                    bins=20,\n",
    "                    ax=ax6)\n",
    "     \n",
    "     ax6.axvline(mean2, \n",
    "                 color='r', \n",
    "                 linestyle='solid', \n",
    "                 linewidth=2,\n",
    "                 )  \n",
    "     ax6.set(\n",
    "        xlabel=f'Per Pixel Probability, Mean: {mean2: .3g}')\n",
    "     \n",
    "     if savefig == True:\n",
    "         plt.savefig(os.path.join(fig_out, f'{basin}_{int(val*4)}mmhr_by6.png'))   \n",
    "     plt.show()\n",
    "     return fig    "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
